[{"title":"SpringAnimation","date":"2018-02-11T06:39:40.000Z","url":"/2018/02/11/SpringAnimation/","tags":["SpringAnimation","动画"],"content":"在浏览app的时候，突然发现这个app的启动动画不错。搜索了下可以使用SpringAnimation来实现。在打开主页的时候，同时打开启动页或者打开主页的时候，弹出一个弹框来展示启动页的动画。"},{"title":"人生有何意义-胡适","date":"2018-01-20T08:09:25.000Z","url":"/2018/01/20/%E4%BA%BA%E7%94%9F%E6%9C%89%E4%BD%95%E6%84%8F%E4%B9%89-%E8%83%A1%E9%80%82/","tags":["思考"],"categories":["思考"],"content":"人生有何意义胡适一 答某君书 ……我细读来书，终觉得你不免作茧自缚。你自己去寻出一个本不成问题的问题，“人生有何意义?”其实这个问题是容易解答的。人生的意义全是各人自己寻出来，造出来的：高尚、卑劣、清贵、污浊、有用、无用，……全靠自己的作为。生命本身不过是一件生物学的事实，有什么意义可说?生一个人与一只猫，一只狗，有什么分别?人生的意义不在于何以有生，而在于自己怎样生活。你若情愿把这六尺之躯葬送在白昼做梦之上，那就是你这一生的意义。你若发愤振作起来，决心去寻求生命的意义，去创造自己的生命的意义，那么，你活一日便有一日的意义，做一事便添一事的意义，生命无穷，生命的意义也无穷了。 总之，生命本没有意义，你要能给他什么意义，他就有什么意义。与其终日冥想人生有何意义，不如试用此生做点有意义的事。…… 1928年1月27日 二 为人写扇子的话 知世如梦无所求，无所求心普空寂。 还似梦中随梦境，成就河沙梦功德。 王荆公小诗一首，真是有得于佛法的话。认得人生如梦，故无所求。但无所求不是无为。人生固然不过一梦，但一生只有这一场做梦的机会，岂可不努力做一个轰轰烈烈像个样子的梦?岂可糊糊涂涂懵懵懂懂混过这几十年吗? 1929年5月13日"},{"title":"Synchronized","date":"2017-12-19T14:30:10.000Z","url":"/2017/12/19/Synchornized/","tags":["Java","Synchronized"],"categories":["Java"],"content":"锁，是用来在多线程做同步操作，是线程同步的一种实现方式，锁住需要同步代码，只能让单个线程访问。锁住的是一个对象，对于这被锁住的对象，加了锁的会同步访问，没有加锁的就随机访问。锁代码块，方法，对象，类。要区分他们的作用范围。block&lt;=Method&lt;Object&lt;Class 锁Block的时候，锁方法所有的代码就相当于锁方法 锁Object的时候，他的所有的方法都同步执行。 锁Class的时候，他的所有类对象执行到这个锁的地方是，都同步。 锁代码块一个线程访问锁住的代码块时，一定是按次序来。在方法中对于余下没有锁住的是随机的。这个随机要看线程获取CPU的能力强弱，先获取就先执行。至于执行多少，要看在每个CPU执行片段期间到底执行了多少。 JSBySynchronizedBlock被锁的代码块是同步访问，其他的就随机 锁方法在方法前面加synchronized，public synchronized void method(){//todo}。作用范围是整个方法，而锁代码块的作用方法是synchronized{}花括号的内容。所以以下两者是等效的 synchronized关键字不能继承 synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。 如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，必须显式地在子类的这个方法中加上synchronized关键字才可以同步。还可以在子类方法中调用父类中的方法super，单余下的其他的代码还是非同步的。 在子类方法中加上synchronized关键字 在子类方法中调用父类的同步方法 JSBySynchronizedExtend 在定义接口方法时不能使用synchronized关键字。 构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。 锁静态方法 JSBySynchronizedStaticMethod 静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。 锁对象 JSBySynchronizedObject 对于这个被锁住的对象，调用该对象的所有的方法都会同步。然后，对于多个同时锁改对象的代码块内部也是同步的（不是该对象的其他的方法）也是同步的。 锁类不是在类申明的时候加锁而是 JSBySynchronizedClass效果跟锁类的静态方法一样，对于类的所有对象，调用锁类方法都会同步。 参考Java中synchronized的用法"},{"title":"Gradle 依赖申明方式","date":"2017-12-12T07:09:45.000Z","url":"/2017/12/12/Gradle%20%E4%BE%9D%E8%B5%96%E7%94%B3%E6%98%8E%E6%96%B9%E5%BC%8F/","tags":["Android","依赖申明"],"categories":["Android"],"content":"在《Gradle For Android》中写到Gradle的依赖就是一系列的文件集合，一些标准的概念： compile apk provided testCompile androidTestCompile compile默认的配置，将所依赖的buildeType或Flavor都编译。将添加到cliassPath和生产的apk文件中。apk中的依赖只会要添加到最终的apk中，不参与编译。provided于apk正好相反，不会添加到apk中，只在编译使用。apk和provides两个只能使jar依赖，添加Library将会报错。testCompile和androidTestCompile只是用在测试过程中。只会执行在测试相关的任务中。只会被打包到test相关的apk，而不是release相关的apk 在AS3.0之后引入了新的概念implementation和api,用来替换compile。有点强力推荐的感觉： The compile configuration still exists but should not be used as it will not offer the guarantees that the api and implementation configurations provide. implementation只能在当前模块使用，不能向外暴露出去。这样做的好处是： 依赖关系不会泄漏到消费者的编译类路径中，所以永远不会意外地依赖于传递依赖项 由于减少的类路径大小编译更快 当实现依赖关系发生变化时，重新编译会更少：消费者不需要重新编译 cleaner发布：当与新的maven-publish插件结合使用时，Java库会生成POM文件，这些文件可以精确地区分编译库所需的内容和运行时使用库所需的内容（换句话说，不要混合编译library本身所需的东西，以及编译library所需的东西）。 api当前的模块可以用，并且可以向外暴露给其他模块使用。跟以前的compile功能一样。 用处引用Library的时候会遇到，某个库版(比如glide)版本不匹配。解决方式是不使用Library的库A 现在可将Library的Glide依赖改为implementation就可以了。 想外部使用就是api，不想让外部使用就是implememation 参考java_library_separationGradle配置implementation、api与compile的区别Implementation Vs Api in Android Gradle plugin 3.0"},{"title":"Android 状态栏高度-屏幕划分-正确获取标题栏高度","date":"2017-11-19T05:13:45.000Z","url":"/2017/11/19/Android%20%E7%8A%B6%E6%80%81%E6%A0%8F%E9%AB%98%E5%BA%A6-%E5%B1%8F%E5%B9%95%E5%88%92%E5%88%86-%E6%AD%A3%E7%A1%AE%E8%8E%B7%E5%8F%96%E6%A0%87%E9%A2%98%E6%A0%8F%E9%AB%98%E5%BA%A6/","tags":["状态栏高度","导航栏高度"],"categories":["Android"],"content":"需求今天的需求是要获取到状态栏的高度没因为UI是全屏填充到顶部。通过margin来控制是否显示到状态栏下面。在网上看到一个见解：不同的Android设备状态栏的高度不一样。240x320高度是20px,320x480高度是25px，480x800是38px。记得以前有人说是25px，所以是不对的。获取方式是根据Window来获取： height-of-status-bar-in-android 将这块整理一下。getWindowVisibleDisplayFrame()从方法的描述老看：获取窗口可视区域，方法需要IPC的支持，所以不应该用在关键处的代码（critical code），比如draw方法中。而且需要View已经attach到Window的时候才会有值。 由于getWindowVisibleDisplayFrame()方法是View类下的一个方法，所以只能通过View对象来调用。一个窗口中通常都会有多个View，getWindowVisibleDisplayFrame()方法的返回结果和该窗口中选取的View并没有关系。在某个时刻，使用当前窗口中的任意View执行getWindowVisibleDisplayFrame()返回的结果都是一样的 getWindowVisibleDisplayFrame()方法返回的是窗口的可视区域大小，并非某个View的可视区域大小，所以用窗口中的任意View来执行都是没有差别的。 联系之屏幕的划分手机展示的界面从上到下依次是 状态栏（包含通知，系统时间）， 然后是应用的标题栏， 应用的View布局栏， 以及底部的导航栏。 有的手机有实体按钮所有没有底部的导航栏。 获取屏幕的宽、高 状态栏 View布局绘制区域即Content 标题栏 应用内容区域=&gt;标题栏+View布局绘制区域 导航栏 结果一个Activity是附着在一个Window上的。Window中包含一个顶级视图DecorView，DecorView中只有一个线性布局的child叫mContentRoot。mContentRoot包含mContentparent、标题栏。而mContentParent就是setContentView所加载的布局的容器，资源id是content。 getDecorView() 是不包含状态栏的。所以他的区域rect.top就是状态栏高度。 getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect)就是获取的内容区域，所以rect.top获取的就是状态栏的标题栏的高度。 所以屏幕的高度=状态栏高度+DecorView高度+导航栏的高度&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;=状态栏高度+标题栏高度+content高度+导航栏高度 但是结果并不是这样：(Px_XL_1440x2560) 标题栏和content的高度与decorView的高度之间差了一个状态栏的高度。奇怪？ 状态栏和导航栏肯定是对的，因为直接从资源里面取出来的，decorView的高度是直接获取的没有问题。问题就出在标题栏高度、content高度上。 手动将标题栏和content高度打印出来：以及content的top，windowFrame以及DrawingRect打印出来：日志： 发现window的高度是2392，content的bottom-top等于2112，获取到的高度也是2112。所以content的高度是对的。哪问题就出在title的高度了，两个的差值是196。刚刚求标题栏高度是contentViewTop-statusBarHeight。所以问题就出在这，因为： contentViewTop就是content在父容器DecorView的坐标位置，就是标题栏的高度。所以标题栏高度： noActionBar: 参考Android获取窗口可视区域大小: getWindowVisibleDisplayFrame()android 屏幕划分深入浅析Android坐标系统"},{"title":"Android-O安装未知应用","date":"2017-11-12T07:16:11.000Z","url":"/2017/11/12/Android-O%E5%AE%89%E8%A3%85%E6%9C%AA%E7%9F%A5%E5%BA%94%E7%94%A8/","tags":["Android"],"categories":["Android"],"content":"Android O中应许安装未知应用来源的开关没有了，取而代之的是每个应用单独申请安装权限。所以targetSdkLevel是26或者更高的要做优化，不然应用将无法安装其他应用。 具体操作1、申明 对申明这个就可以了。 2、其他操作2.1 授权通过 ACTION_MANAGE_UNKNOWN_APP_SOURCES打开app的安装位置应用授权界面： 另外是否添加权限还是有区别的（安装未知应用）： 未添加权限 添加权限 2、2检查权限通过PackageManager canRequestPackageInstalls() API，查询此权限的状态 参考在 Android O 中更安全地获取应用"},{"title":"AIDL","date":"2017-06-25T01:23:18.000Z","url":"/2017/06/25/AIDL/","tags":["AIDL","接口语言"],"categories":["Android"],"content":"AIDLAIDL(Android Interface Definition Language,Android接口定义语言)是Android中用于两个进程间通讯（interprocess communication, IPC）且都互相认可的编程接口。 为什么需要在 Android上由于虚拟机的特性，每个应用都处在自己的进程中 。一个进程通常无法访问另一个进程的内存，这个时候如果需要与其他的进程或者说app进行交互就需要用到AIDL。或者说，为了实现进程之间的相互通信，Andorid采用了一种轻量级的实现方式RPC(Remote Procedure Call），通过AIDL来生成两个进程之间相互访问的代码。在官网上提到：只有允许不同应用的客户端用 IPC 方式访问服务，并且想要在服务中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。就是说： 应用内部使用：扩展Bindler IPC：Messenger 多线程并IPC：AIDL 怎样实现必须使用 Java 编程语言语法在 .aidl 文件中定义 AIDL 接口，然后将它保存在托管服务的应用以及任何其他绑定到服务的应用的源代码（src/ 目录）内。通常会以一下四步走： 定义AIDL文件以及申明接口 实现AIDL接口 向客户端暴露接口 调用接口进行通讯 定义AIDL接口既然要通讯，这里要明白三个事情。 AIDL默认支持的数据类型：java基本的原始数据类型（int、long、char、boolean）以及String，CharSequence，List，Map。至于其他的数据，只支持序列化Parcelable。序列化的数据在定义接口的时候必须显示的import，而且数据类与申明的数据类的AIDL文件在包名和类名上要意义对应。比如这样： 所有非默认支持的参数要指示数据走向的方向标记 in、out 或 inout。 只支持方法；您不能公开 AIDL 中的静态字段。然后创建文件，申明接口。 然后申明接口： 编译的时候会生产.java 扩展名的文件 实现AIDL接口创建一个服务,申明的时候要显示的标记服务的进程（:表示创建一个只属于当前app新的进程，没有冒号会创建一个都可用的进程）。我们需要实现实现 .aidl 生成的接口即IInterCommunication.Stub接口，该接口会返回一个Binder对象用于绑定服务。关键代码： 向外暴露接口实现 Service 并重写 onBind() 以返回 Stub 类的实现。 调用接口进行通讯bind服务，在onServiceConnected()方法中拿到接口对象。 onServiceConnected() 实现中，收到一个 IBinder 实例（名为 service）。调用 YourInterfaceName.Stub.asInterface((IBinder)service)，以将返回的参数转换为 YourInterface 类型。拿到接口后就可以在客户端端于服务端主动通讯了（get和send）。 get send 如果服务想主动向客户端通讯，必须通过注册回调的方式来进行。比如在onServiceConnected()中的registerCallBack。注册回调的时候要注意，如果客户端被意外的杀死，我们需要取消注册的回调。不然当服务调用回调的时候会发生DeadObjectException，还会浪费资源（引用），但是这种情况服务是不方便收到app进程被杀死的消息的。Binder提供了进程得到意外退出通知的机制：Link-To-Death，Android提供了RemoteCallbackList来处理这个典型的使用场景。 好处把服务开启在一个新的进程的可见减少对app进程的内存占用，减少应用的app进程没回收的概率。在IM通讯中会把通讯的逻辑放在新的进程中，比如逸创云客服的聊天。 遇到的错误提示我AIDL版本不对 问题出在我想传递一个序列化对象，结果.java文件与.aidl文件路径不一致。就是说传递的序列化对象路径和文件名要一致。 找不到符号 XXX.readFromParcel(_reply)这里将序列化对象的流向改为out，报此错。查看aidl生产的.java文件，对应的方法显示的调用了readFromParcel()。所以在实体类已经实现Parcelable的情况下，会有一个带Parcel参数的构造方法，没错，复制该构造方法改为为pubic void，改掉方法名为readFromParcel即可。"},{"title":"Android-Handler","date":"2017-05-06T06:15:02.000Z","url":"/2017/05/06/Android-Handler/","tags":["Android","Handler"],"categories":["Android"],"content":"关于Android中的Handler，其实并不陌生。初入Android时写网络模块的时候，经常会用到，因为Android中3.0版本之后是不应许在主线程中直接调起网络请求，所以只有在子线程中开启网络请求。而Android中不应许在子线程中操作UI，所以要界面响应网络请求的结果，就需要通过Handler来刷新UI。后来网络请求框架如雨后春笋般崛起，自己再去通过Handler来刷新界面就用的少了。再后来用的多的地方是使用Handler的延时效果。 用途预处理（将来的某个时间点上要做）线程间通信（异步） 理由为什么在子线程中发送一个消息，主线程就能收到呢，或者说Handler是怎实现线程间是怎么通信的？这里需要明白Android是消息驱动型系统（于Windows一样），消息驱动系统的四要素： 接受消息的”消息队列” 阻塞式地从消息队列中接收消息并进行处理的“线程” 可发送的消息格式 消息发送函数在Android中表现为： MessageQueue Thread+Looper Message Hander的post与sendMessage函数Handler发送一个消息到MessageQueue处。Looper相当于线程的消息管家，不断的在MessageQueue中读取消息，将消息分发给Handler处理，从而就实现的线程间的通信。盗一张别人的原理图：所以实现线程间通信，光有Handler是不够的，你得有配套的机制。而线程默认是没有Looper的，你得使用Looper.perpare()创建Looper，然后创建Handler，让管家管理消息即Looper.loop()。大致思路是这样： 判定是否已有Looper并Looper.prepare() 做一些准备工作(如暴露handler等) 调用Looper.loop()，线程进入阻塞态比如这样： 那么如果有人问你，Thread，Looper，MessageQueue，Handler数量关系是怎么样的。你可以这样告诉他。一个Thread最多只拥有一个Looper，一个Thread却是可以有多个Handler。那么怎么理解Handler的异步或者说异步通信呢？我在主线程里面要网络数据，但是我是莫法在主线程里面直接访问网络的，所以我叫子线程去访问网络，子线程要把网络请求的结果告诉主线程，这个告诉就是回调，就是响应，通过Handler来完成。从而体现了异步。参考 Handler引起的内存泄漏这里主要明白非静态内部类会持有外部类的引用。所以在申明Handler的时候不要申明成static的，如果非要申明为static的就要一层如引用包裹Handler。在onDestroy的时候移除所以的消息和回调removeCallbacksAndMessages(null) 参考官网 Android异步消息机制Handler详解，源码剖析Android Handler机制"},{"title":"Java-网络","date":"2017-04-10T11:35:43.000Z","url":"/2017/04/10/java-%E7%BD%91%E7%BB%9C/","tags":["Socket"],"categories":["Java译文"],"content":"网络编程指的是让所写的代码在几个设备之间运行，为的是将这些设备通过网络彼此相连。在J2SE下的java.net包中的API，提供了一些低级别的类和接口，帮助你专注于解决手上的问题。java,net 包提供了两种网络协议： TCP 传输控制协议，应许你在两个设备之间建立连接。TCP协议广泛使用与网络协议中，被称为TCP/IP. UDP 用户数据协议，一种无连接协议，允许数据包在应用程序之间传输。本文将了解以下两个主题： Socket Programming,网络编程中最广泛使用的概念并且也是解释的最清楚的一部分。 URL Processing,将单独讲解，连接。Socket ProgrammingSockets提供了两个电脑相互通讯的机制。客服端在交流后建立了socket并且尝试去链接服务端。当链接建立过后，服务端也在交流后建立的socket。然后客户端和服务端能够通过写和读来通讯。java.net.Socket类提供了一个socket，java.net.ServerSocket类提供了服务端监客户端并建立链接的机制。以下表示了两台电脑通过tcp建立链接的步骤： 服务端创建 ServerSocket对象，提供那个端口将用于通讯。 服务端调用ServerSocket的accept()方法。方法将等待之道客户端链接到刚刚指定的端口。 在服务端处于等待的时候，客户端创建Socket对象，并指定需要链接的服务端地址以及端口号。 Socket类的构造方法尝试将客服端与所指的服务端以及端口。如果链接建立了，客户端就有用能和服务端通讯的Socket对象。 在服务端，accept()方法将返回一个可以与客户端链接成功的Socket对象。在链接建立成功过后，将通过I/O流的方式进行通讯。每个Socket对象都拥有OutputStream和InputStream。客户端的InputStream链接的是服务端的OutputStream,OutputStream链接的是服务端的InputStream。Tcp是双向的通讯协议，意味着可以同时在各自的流之间发送数据。以下是提供完整的实现套接字方法的有用类。ServerSocket 类方法 序号 方法和描述 1 public ServerSocket(int port) throws IOException 创建ServerSocket对象并绑定指定的端口，如果端口已经被其他的绑定了抛出异常 2 public ServerSocket(int port, int backlog) throws IOException backlog参数指定了有等待队列将能够存储多少传入客户端 3 public ServerSocket(int port, int backlog, InetAddress address) throws IOException InetAddress参数指定了绑定的本地的地址，InetAddress用于服务端有多个IP地址，指定某个确定的地址用于客户端的绑定 4 public ServerSocket() throws IOException 创建一个非绑定的对象，当你需要绑定服务时调用bind()来绑定ServerSocket 如果ServerSocket的构造方法没有抛出异常，表明你的程序已经成功的绑定了指定的端口，等待客户端的链接。 ServerSocket的常用方法： 序号 方法和描述 1 public int getLocalPort() 返回服务端监听的端口。这个方法是有用的在你构建的时候传递0作为参数给构造方法，让他自己为你寻找可用的端口。 2 public Socket accept() throws IOException 等待客户端的连入。方法将一直阻塞，知道客户端链接或者等待超时，假设已经过setSoTimeout()方法设置了超时时间。否者方法将永远阻塞 3 public void setSoTimeout(int timeout) 设置服务端等待客户端连入的等待时间 4 public void bind(SocketAddress host, int backlog) 将套接字绑定到SocketAddress对象中指定的服务器和端口。如果您使用无参数构造函数实例化了ServerSocket，请使用此方法。 当ServerSocket的accept()方法调用后，只有客户端链接过后才会返回。在客户端链接过后，ServerSocket在未指定的端口上创建一个新的Socket，并返回对此新Socket的引用。此后TCP链接将在客户端和服务端之间，回话开始。 Socket 类方法java.net.Socket 类提供了一个可以和服务端进行交流得到Socket对象。客户端通过创建获得一个Socket对象，服务端通过accept()方法获得Socket对象。Socket有5个构造方法用于去链接服务端。 序号 方法和描述 1 public Socket(String host, int port) throws UnknownHostException, IOException. 尝试根据指定的服务地址和端口链接服务端。如果不抛出异常表示链接服务端成功 2 public Socket(InetAddress host, int port) throws IOException 跟上面的方法一样，只是服务端的地址是InetAddress对象 3 public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException. 链接指定服务端地址和端口，并在本地的地址和端口创建socket对象 4 public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException. 于前一个方法类似，只是服务端的地址是一个InetAddress对象而非String 5 public Socket() 创建一个不立即建立的Socket对象。使用connect()方法链接服务端 构造方法返回的不仅仅只是一个Socket对象，而是一个尝试去链接指定地址和端口的服务端的Socket对象。Socket类的一些常用方法如下一。注意客服端个服务端都有socket对象，所以一下方法两者都可以调用。 序号 方法和描述 1 public void connect(SocketAddress host, int timeout) throws IOException 链接指定的服务端。改方式仅仅只是在调用Socket的无参构造方法时需要需要 2 public InetAddress getInetAddress() 返回电脑中Socket对象的链接地址 3 public int getPort() 返回Socket对象绑定的远程机上的端口 4 public int getLocalPort() 返回Socket对象绑定的本地上的端口 5 public SocketAddress getRemoteSocketAddress() 返回远程Socket对象地址 6 public InputStream getInputStream() throws IOException 返回Socket的输入流，其实与远程的输出流链接 7 public OutputStream getOutputStream() throws IOException 返回Socket的输出流，其与远程的输入流链接 8 public void close() throws IOException 关闭Socket，是的Socket对象不再能够再次连接到任何服务器 ## InetAddress 类方法 这个类表示Internet 协议地址即IP。下面是Socket编程中常用的方法。 序号 方法和描述 — — 1 static InetAddress getByAddress(byte[] addr) 给出给定原始IP地址的InetAddress对象 2 static InetAddress getByAddress(String host, byte[] addr) 根据指定的地址返回InetAddress对象 3 static InetAddress getByName(String host) 确定主机名称的IP地址。 4 String getHostAddress() 以文本形式返回IP地址 5 String getHostName() 返回主机地址 6 static InetAddress InetAddress getLocalHost() 返回本地地址 7 String toString() 返回Ip的String Socket编程例子 Socker 服务端例子 输出 原文"},{"title":"Android开发中地图坐标系以及调用地图导航","date":"2017-04-08T01:50:55.000Z","url":"/2017/04/08/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8%E5%9C%B0%E5%9B%BE%E5%AF%BC%E8%88%AA/","tags":["Android地图","地图坐标系"],"categories":["Android"],"content":"android开发中你会使用到地图，国内常用的地图有高德，百度，腾讯。这里主要谈一下各自的坐标系，以及如何在app里面调起他们的地图app导航。 地图坐标系地球人共同约定的地图准则。 WGS84：国际通用的地球坐标系。Google地图非中国范围在使用。 GCJ102:WGS84坐标系经加密后的坐标系，又名火星坐标系。Google地图中国范围，高德，腾讯在使用。 BD09：GCJ02坐标系经加密后的坐标系，又名百度坐标系。百度在使用。 国际上最常用的是WGS84，在国内是GCJ102，因为国家地理测绘总局对于出版地图的要求，出版地图必须符合GCJ02坐标系标准了，也就是国家规定不能直接使用WGS84地理坐标系。所以在你拿到地图的数据时，调起各自的地图app进行导航，就需要将数据进行转换。不然你的点位是有很大的偏差。在高德，百度，腾讯的地图开发平台都提供了，如何将其他的地图数据转换成自家的。 转换到百度链接: 转换到高德链接: 转换到腾讯链接: 这样你就必须要集成三家的sdk，项目有点点大。网上也有一些偏方，见文末提供的代码。 调起导航各自需要发送的intent如下： 百度链接: 高德链接: 腾讯链接: 附上网上的偏方： "},{"title":"AndroidManifest-Merge","date":"2017-03-06T14:05:53.000Z","url":"/2017/03/06/AndroidManifest-merge/","tags":["合并清单","Merge Manifest"],"categories":["Android译文"],"content":"一个apk只会包含一个清单（AndroidManifest）文件，但是在androidStudio下你的工程会有多个清单文件来自于-主modle下，build variants，依赖的库（依赖的Modle，aar）。所以在运行工程的时候，gradle会合并这些清单成一个清单。清单合并工具合并所有的XML元素（elements）是遵循合并启发和一些你在特定XML的属性（attributes）所指定的偏好。本文将展示清单是怎样合并的以及怎样解决合并带来的冲突。提示：使用 Merged Manifest view 来查看合并的结果和查找冲突。 合并优先级合并工具合并所有的清单文件到一个里面是基于清单文件的优先级（priority）。比如，你又三个清单文件，优先级最低的清单合并到高一点的优先级清单中，然后高一点优先级的清单合并到最高优先级清单文件里面。as illustrated in figure ：合并三个清单文件的过程，最低优先级（左）到最高优先级（右）这里有三个基本类型的清单文件可以被合并到彼此中，合并优先级如下（从高到低）： build variant清单文件。如果你又多个build variant，他们的清单优先级如下： Build variant清单（像src、demoDebug/） Build type清单（像src/debud） Product flavor 清单（像src/demo） 如果你使用的是flavor,他们的优先级对应于在flavorDimensions所列出来的那样（第一个是最高的。 主Modle工程的清单 依赖工程清单。如果你又多个依赖项目，他们的清单优先级与你依赖顺序有关（它们在Gradle依赖项块中出现的顺序）。 比如说依赖项目的清单文件合并到主Modle的清单，然后主Modle的清单在合并到build variant的清单中。注意：在 Build with source sets.中列出的是相同的优先级。重要：build.gradle文件中构建配置信息会覆盖其他的合并清单的相应属性。比如，buidl.gradle的minSdkVersion配置会覆盖掉其他清单的 &lt;uses-sdk &gt; 元素。为了避免冲突，你应该忽略其他清单的&lt;uses-sdk&gt;并且只在build.gradle文件中定义这些配置。更多细节参考 Configure Your Build。 合并冲突启发式heuristics合并工具理论上来说可以上将来自一个清单的每个XML元素与另一个清单中的相应元素进行匹配（更多参考 merge policies ）。如果一个低优先级清单的某个元素在高优先级中没有匹配，那么元素将添加到高优先级清单中。然而如果某个元素匹配到了，合并工具将尝试将元素的所有属性合并到高优先级清单中。如果合并工具发现，两个清单中相同的属性有不同的值，就会发生冲突（译：匹配到的元素的属性）。下表展示了合并工具合并所有属性到一个元素的结果。表一：然而，一下这些情形是合并工具尝试避免冲突的行为： &lt;manifest&gt;元素的属性是不会合并的-即只使用高优先级清单的属性。 在&lt;uses-feature&gt; 和 &lt;uses-library&gt;元素所使用的android:required属性使用 OR规则来合并。必然要如果存在一个冲突，true将应用并且将始终包括一个清单所需的功能或库。 &lt; use-sdk &gt;元素的属性总是使用高策略清单的属性，出了一下几种情况： 低优先级指定的minSdkVersion版本高一些的时候，就会发生冲突，除非你指定了合并规则。 低优先级指定的targetSdkVersion版本低一些的时候，合并工具会使用高优先级的值，并且还会添加了必要的任何系统权限，以确保导入的库继续正常工作（以防高版本增加的系统的权限限制restrictions）。更多参考 implicit system permissions.。 &lt; intent-filter &gt;元素时不会去匹配的。在每个清单中都被独立对待，并且是直接的添加合并后的清单中。对于其他的属性冲突，你将会看到错误，并且你必须指定合并工具怎样去添加这些冲突的属性到高优先级的清单中（请看下面的一张）。注意：不要依赖属性（attribute）的默认值。因为所有的属性值都要合并到元素（element）中去，这也许会出现一些不期望出现的值-高优先级清单没有申明的属性确实依赖它的默认值。比如，一个高优先级的清单没有申明 android:launchMode属性，他使用默认的值standard。但是如果低优先级的清单申明了这个属性用其他的值，然后低清单申明的值将被应用到合并后的清单中（覆盖默认值）。所以你应该明显的指定每一个属性的值。（每一个属性的默认值参见 Manifest reference。）合并规则标记合并规则标记是一个你可以指定的偏好去解决合并冲突和不想要的元素或属性的XML属性 。合并规则标记可以使用在一个元素的所有属性或某个你指定的属性上。所有的规则标记归属在Android tools namespace命名空间 ,所以你必须现在manifest元素里面申明如下： 节点标记为了在一个元素的所有属性上（manifest中所指定的元素的所有属性和他的字节点），使用下面的属性： tools:node=&quot;merge&quot;合并当前标签的所有属性和所有嵌套的元素，如果没有冲突的时候使用前面的合并冲突启示。这是元素的默认的行为。低优先级的清单： 高优先级的清单： 合并结果： tools:node=&quot;merge-only-attributes&quot;只合并当前的标签，不合并嵌套的元素：低优先的清单： 高优先的清单： 合并结果： tools:node=&quot;remove&quot;从合并结果清单中移除当前的元素。虽然他看起来像是你直接删除了这元素，有时候这是很必要的当你在结果清单中发现某个元素是被低优先级清单提供并且你不需要，或者已经超出你的控制范围了（比如一个导入的库）。低优先级清单： 高优先级： 结果清单： tools:node=&quot;removeAll&quot;像tools:node=&quot;remove&quot;一样，但是是移除的所匹配到的元素的所有同名元素（在相同的父元素下）。低优先级： 高优先级： 结果： tools:node=&quot;replace&quot;完全的替换低优先级的元素。也就是说（This is），如果优先级较低的清单中有匹配的元素，忽略它，并使用此元素在高优先级清单中显示的元素显示。低优先级清单： 高优先级的清单： 合并结果： tools:node=&quot;strict&quot;当低优先级中的某个元素在高优先级中没有完全的匹配的时候生产构建错误（除非被其他的合并规则标记解决）。这种情形覆盖了合并规则启发式。比如，如果低优先级清单中简单的指定了一个属性，将报错（而属性的默认值想额外的天骄到合并清单中）。低优先级清单： 高优先清单： 这将发生清单合并错误。连个清单中的这个元素在strict模式下根本不能区分。所以你必须指定合并标记来解决这些不同的地方。（原则上来，在tools:node=&quot;merge&quot;例子中这连个元素将会很好的合并。） 属性标记为了避免只在清单节点中指定的元素属性中运用合并标记，你可以使用以下的属性。每个属性接受一个或多个属性名称（包括属性命名空间），用逗号（commas）隔开。 tools:remove=&quot;attr, ...&quot;从结果清单中移除指定的属性名称。虽然他看起来像是你直接删除了这些属性，这是必要的当低优先级的清单中包含了一些你在结果清单中不想要的属性。低优先级清单： 高优先级清单： 合并结果： tools:replace=&quot;attr, ...&quot;用当前清单的指定属性替换低优先级清单的属性。换句话说，总是使用高优先级清单的值。低优先级清单： 高优先清单： 合并结果： tools:strict=&quot;attr, ...&quot;当低优先级清单的这些属性的值与高优先级的不匹配的时候生产错误。这是所有属性的默认行为。出了模板冲突启发式中描述的那些特定的行为。低优先级清单： 高优先级清单： 这将发错清单合并错误。你必须指定其他的合并标记去解决这个冲突。（记住：这是默认的行为，所以上面的所有例子都会报错如果你加上tools:strict=&quot;screenOrientation”。）你同样可以在一个元素中添加多个标记，如下：低优先级清单： 高优先级清单： 合并结果： 标记选择器如果你执行对指定的导入库添加合并规则，添加tools:selector属性和用依赖库的包名。比如，下面的清单，remove标记仅仅只会在低优先级的依赖库清单神效。 如果是来自其他地方的低优先级清单，remove标记将失效。注意：如果你对属性标记的某一个属性使用了标记，他将应用到所有的属性。 覆盖依赖库的&lt;use-sdk&gt;默认情况下，当导入的库的minSdkServison值比主工程的清单中的值更高时，是会报错的，所有依赖库是不会被导入的。为了让合并工具忽略错误并且保持主工程的较低的minSdkVersion值，添加overrideLibrary标记。属性值可以是一个或多个库包名称（逗号分隔），指示可以覆盖主清单的minSdkVersion的库。比如你的主清单是这样使用overideLabrary： 然后下面的清单在编译&lt;use-sdk&gt;的时候就不会报错,并且合并清单保持主工程的minSdkVersion=&quot;2&quot; 隐式系统权限（implicit）一些android版本的APIs曾经是开放给app使用的，但是在最近的后续的 system permissions 版本已经变得受限制了。为了避使访问这些API的应用程序变得不可访问，最近的Android版本允许应用程序在没有权限的情况下继续访问这些API，如果他们将targetSdkVersion设置为低于添加限制的版本的值。这有效的隐式的授予权限去访问这些APIs。因此，这可以影响具有不同的targetSdkVersion值的合并清单，如下所示。如果低优先级的清单有一个更低的targetSdkVersion，这说明需要提供隐式权限，但是高优先级的清单并不会用于相同的权限（因为他的targetSdkVersion是等于或者高于需要受限制访问权限的版本），也就是说合并工具会自动在结果清单中添加相应的系统权限。比如如果你的apptargetSdkVersion是4或者更高一点，然而导入库的是3或者更低一点，然后合并工具将添加 WRITE_EXTERNAL_STORAGE权限到合并结果中。下面的列表列出了所有有可能被添加的权限。注意：如果的targetSdkVersion是23或者更高，你必须动态申请任何危险的权限当你的app将去访问这些被权限保护的APIs时候。更多， Working with System Permissions.。 检查合并清单以及查找冲突及时在你构建APK之前，你也可以通过打开Android Studio的AndroidManifest.xml来查看你的合并清单，然后点击底部的Merged Manifest选项。合并清单结果在左侧展示了合并的结果，在右侧展示合并清单的具体的信息，如下图所示。从低优先级清单合并而来的元素时高亮的用其他颜色显示在左侧。每种颜色所指定的是右边的清单来源。清单文件是构建过程的一部分，但是不是右边的其他的清单文件贡献的。点击左侧的元素右侧将出现更多的信息关于这个元素合并日志。如果发生了合并冲突，右侧将提示怎样使用合并冲突标记去解决冲突。错误将在Event Log打印出来（select View &gt; Tool Windows &gt; Event Log）。你可以在你的Modle下面的build/outputs/logs/ 路径的取名为manifest-merger-buildVariant-report.txt的文件，查看完全的合并信息。 附录：合并原理清单合并工具原则上是将一个清单的元素与另一个清单响应的元素一一匹配。合并工具通过“match key”来匹配每一个元素：是否是唯一的属性名称（比如：android:name），他本身是否唯一（比如，一个清单中&lt;supports-screen&gt;只能有个）。如果两个清单有相同的元素，合并工具将使用下面的三个原则来合并： 合并把没有发生冲突的属性结合到一起并且根据子元素个字的合并原则合并子元素。如果有任何的元素发生冲突了，根据合并标记来合并。 只合并子类不结合或者合并这些属性（值保留高优先级清单的属性）并且根据子元素各自的合并原则合并子元素。 保持将元素“保留原有”并且添加到公共的合并文件父类中。这仅仅会发生在当可以接受几个元素的申明的时候。表一，列出了每个元素的类型，所使用的合并原则，以及合并两个清单的某个元素的key。表三，清单元素合并原则以及匹配的key。 原文 thinks:AndroidManifest合并原理Manifest合并"},{"title":"Android-Error","date":"2017-03-02T13:09:31.000Z","url":"/2017/03/02/Android-Error/","tags":["Error","Android-Error"],"categories":["Android-Error"],"content":" 资源重名在不同的modle里面有相同名称的布局文件名称。 "},{"title":"Java反射12-动态加载和重加载类","date":"2017-02-28T12:51:39.000Z","url":"/2017/02/28/Java%E5%8F%8D%E5%B0%8412-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%87%8D%E5%8A%A0%E8%BD%BD%E7%B1%BB/","tags":["Java反射","类加载"],"categories":["Java译文"],"content":" The ClassLoader The ClassLoader Hierarchy Class Loading Dynamic Class Loading Dynamic Class Reloading Designing your Code for Class Reloading ClassLoader Load / Reload Example 在程序运行时去加载和重加载类是可能的，虽然它不像我们所希望的那么直接。本文将介绍何时以及怎样去加载和重加载类。你可能会疑问动态加载类功能到底是不是Java反射的一部分，或者说是Java平台核心的一部分。不管怎么说本文将沿着Java反射的轨迹来讲解。 类加载器Java应用的所有的类通过某些java.lang.ClassLoader的子类来加载。因此动态的加载类也必须通过某些java.lang.ClassLoader的子类来完成。当一个类被加载，所有他引用的相关类也被加载了。这种类加载模式以递归（recursively）方式发生，知道所有需要的类都被加载。这也许不会吧应用的所有类的加载了。不被引用的类是不会被加载的直到他们被引用。 类加载层次结构类加载器被层次化的组织起来。当你创建了一个新的加载器ClassLoader,你必须提供他的父类ClassLoader。如果一个加载器ClassLoader加载一个类，那么它会先要求父类去加载这个类。如果父类加载器找不到这个类，子类加载器会尝试去加载这个类。 类加载一个指定的类被加载器加载的步凑是： 检查类是否被加载。 如果没有被加载，叫父类去加载这个类。 如果父类不能加载这个类，子加载器尝试去加载这个类。 当你实现一个能够重新加载类的类加载器时，你将需要从这个序列改变（deviate）一点点。要重新加载的类不应该由父类加载器加载。更多的稍后再谈（More on that later.）。 动态加载类动态加载类是很容易的。所有你需要做的就是获取ClassLoader并且调用他的loadClass()方法。例子如下： 动态重加载类这个有一点点挑战。Java的类加载器在加载类的时候总是先会检查一个类是否已经被加载了。因此重新加载一个类通过Java预定义的ClassLoader是不可能的。所有你需要实现你自定义的ClassLoader。即使是你自定义类加载器也是富有挑战的。每个被加载的类需要关联起来。这可以通过ClassLoader.resolve()方法实现。这个方法是final的，因此不能在你自定义的类加载器中重写。resolve()方法不会应许一个类被两次关联。因此每次你想要去重新加载一个类的时候，你必须指定一个新的你的自定义来加载器。这不是不可能的，但是在设计类重载时需要知道。 设计你的重加载类代码正如前面说到的你不能通过一个类加载器加载已经被加载过的类。因此你必须通过另外的类加载器对象来再次加载这个类。但是这会带来一些新的挑战。Java中的每个被类加载器加载过得类都通过类的独立名称来确认，比如(包名+类名)。这就意味着一个被A加载器加载的MyObject类，在被B加载器加载过后是不同的两个类。比如像下面的代码： 注意到MyObject类的对象object在代码中是怎么被引用的。这因为MyObject类是由加载此代码所驻留的类的相同类加载器加载。如果myClassReloadingFactory对象重新加载MyObject类使用的是其他的类加载器，而不是像上面代码那样使用的同一个类加载器，你就不能将加载得到的类对象转换为当前的MyObject对象。只要两个不同的加载器加载了MyObject类，他们就被任务是两个不同的对象，即使他们有相同的独立类名称。如果你尝试将一个对象转换成另外一个对象会爆出ClassCastException异常。可以解决这个限制，但是你必须以两种方式更改代码： 使用接口作为变量类型，只需重新加载实现类。 使用超类作为变量类型，只需重新加载子类。 代码如下： 如果在重新加载实现类或子类时不重新加载变量类型，即接口或超类，这两种方法都将工作。为了使上面的情况工作，你当然需要实现你的类加载器的父类加载器去加载接口或超类。当你的类被询问去加载MyObject类的时候，它同时也会被询问去加载MyOnjectInterface接口，或者MyObjectSuperclass父类。类加载器必须将这些类的加载委托给包含接口或超类类型变量的类同一个类加载器。 类的加载重加载列子上文有太多的描述。让我们看一个简单的例子。下面是一个简单的ClassLoader的子类。留意到他是怎么讲类加载委托给他的父类来加载，除了一个它自己想加载的类。如果一个类的加载被委托给了它的父类，那么这个类在后面就不能被加载了。记住，一个类只能被一个ClassLoader对象加载一次。正如前文所述，这仅仅是个像你展示ClassLoader怎样运行的例子。它不是一个正式的模板对于你自己的类加载器。你自己的类加载器不要局限于加载一个类，应该是一系列你想要去加载的类。此外，你应该也不应该硬编码类路径（译：直接写一个类的全路径）。 下面是MyClassLoader的使用： reflection.MyObject类通过加载器加载。注意到他是怎么继承父类并实现接口的。这仅仅是一个例子。在你自己的代码中你仅仅只需要两个钟的一个-继承或者实现。 原文"},{"title":"Java反射11-动态代理","date":"2017-02-26T13:31:23.000Z","url":"/2017/02/26/Java%E5%8F%8D%E5%B0%8411-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","tags":["Java反射","动态代理"],"categories":["Java译文"],"content":" Creating Proxies InvocationHandler’s Known Use Cases Database Connection and Transaction Management Dynamic Mock Objects for Unit Testing Adaptation of DI Container to Custom Factory Interfaces AOP-like Method Interception Java反射使得你可以在程序运行时能动态实现接口。你可以通过java.lang.reflect.Proxy来实现。这个类的名称是为什么我将这些动态接口实现称为动态代理。动态代理在许多不同情形下回使用。比如数据库的链接，事务管理，单元测试的动态摸你对象，还有像AOP比如方法拦截。 创建代理你可以使用Proxy.newProxyInstance()方法创建代理。方法需要3个参数： 类加载器（ClssLoader）用于动态的加载类。 一组接口的数组将要被实现的。 一个用于所有方法去调用的代理的 InvocationHandler。例子如下： 在运行了这段代码过后，proxy对象就动态的实现了MyInterface接口。所有调用proxy的方法都传递到实现了InvoicationHanler接口的handler对象。接下来就讲解InvoicationHandler。 InvoicationHanlder‘s正如前文Proxy.newInstance()方法必须提供一个InvoicationHanler。对动态代理的所有方法调用都将转发到此InvocationHandler实现。InvoicationHanler是这样定义的： 一个实现的接口的列子： 传递给invoke()方法的参数proxy是实现了接口的动态代理对象。通常你不需要这个对象。传递给invoke()方法的参数Method对象表示的是调用代理实现方法的方法。对于这个Method对象你可以获取到方法的名称，参数类型，返回类型等。参见前面的‘Method’文章。这个Object[]数组包含了方法调用的时候传递给proxy对象对应的参数。注意：在实现的接口里面，基本的数据类型（int，long）被包裹成对应的对象（Intger,Long等）。 已知用例动态代理被用于至少在以下的情形： 数据库连接和事务管理 单元测试模拟对象 Adaptation of DI Container to Custom Factory Interfaces AOP方法拦截 数据库连接和事务管理Spring框架为你提供了一个可以提交，回滚一个事物的事物代理。至于具体是怎样工作的在文章 Advanced Connection and Transaction Demarcation and Propagation有具体的描述，所以我只是简单的阐述一下。调用顺序如下： 单元测试中动态模拟对象 Butterfly Testing Tools使用动态代理实现动态存根，模拟和代理单元测试。当测试类A用到了另外的类B（接口），你可以传递一个B的模拟实现到A而不是传递一个真的B。所有调用B的方法都被记录了，你可以设置返回的B的值。 Adaptation of DI Container to Custom Factory Interfaces依赖注入容器Butterfly Container具有一个强大的功能，允许您将整个容器注入由其生成的bean中。但是如果您不希望依赖容器接口，容器能够适应您的设计的自定义工厂接口。你仅仅需要的是这些接口。没有被实现的。因此工厂的接口和你的类大概是这个样子： 当MyAction类调用通过MyAction类构造方法传递进来的IMyFactory对象的方法时，方法调用转换为对IContainer.instance（）方法的调用，IContainer.instance（）方法是用于从容器获取实例的方法。这就是为什么一个对象能够在运行时把Butterfly Container当做一个工厂，而不仅仅是在创建时将依赖注入自身。并且这在Butterfly Container没有任何的的依赖。 AOP-like Method Interception在Spring框架中是有可能在指定的Bean调用方法之前拦截该方法的，理由是bean实现了某些接口方法。Spring框架将bean包装在动态代理中。所有对bean的bean调用都被拦截了。动态代理也能在对其他对象调用的时候进行检查，而不是在将方法调用委托给bean包装之后。 原文"},{"title":"Java反射10-数组","date":"2017-02-26T09:40:21.000Z","url":"/2017/02/26/Java%E5%8F%8D%E5%B0%8410-%E6%95%B0%E7%BB%84/","tags":["Java反射","Array"],"categories":["Java译文"],"content":" java.lang.reflect.Array Creating Arrays Accessing Arrays Obtaining the Class Object of an Array Obtaining the Component Type of an Array 通过Java反射操作数组有时候有点棘手。尤其是当你获取是准确的数组对象，比如int[]等。本文将讲述通过Java反射来创建数组以及得到他们的对象。注意：在阅读了Eyal Lupu - All About Java本文已经更新了。本文引用了它的观点。 java.lang.reflect.Array通过Java反射来操作数组是通过java.lang.reflect.Array来完成的。不要和java.util.Array中的数组搞混淆了。后者包含了一些了的有效的数组排序，转换成集合的方法等。 创建数组通过Java反射创建数据是通过java.lang.reflect.Array类完成的。例子中展示了怎样创建数组： 例子中创建了一个int类型的数组。Array.newInstance()方法的第一个参数告诉了我们数组的元素类型。第二参数告诉了数组的长度。 访问数组使用Java反射是能够访问数组中的每个元素的。这是通过Array.get(...)和Array.set(...)方法完成的。例子如下： 代码将输出： 获取数组的类对象在我使用脚步语言Butterfly DI Container的时候，总会有个问题怎样通过Java反射区去获取数组对象的类对象。如果不适用反射的话，你可以这样获取： 使用Class.forName（）这样做不是很简单。比如你可以想下面这样获取基本数据类型的int型数组。 JVM通过字母I表示int。在I左边的[字符表示我申明的是int型数组的的类。其他基本的数据类型都可以这样做。对于其他的对象型数据类型获取方式略有(slightly)不同。 注意类型左边的到[L和右边的;符号。这意味着返回一个指定类型的数组。作为反例，能不能通过Class.forName()来获取基本的数据类型数组。下面的列子将会报ClassNotFoundException： 我通常像下面的方式来获取基本的数据类型和对象型数据的类名： 一旦你获取到了类的类型，这里有一张简单方式来获取类的数组。你也需叫做解决方式，是先创建一个空的指定类型的数组，然后从这个空的数组中获取指定的类对象。这看起来是个骗人的，但是确实有效的。代码如下： 这提供了一个单一的，统一的方法来访问任何类型的数组的数组类。没有使用到类名等等。为了确认类对象确确是一个数组，你可以使用Class.isArray()方法来检查。 获取数组的主键类型一旦你获取到了数组的类对象，你可以使用Class.getComponentType()获取到他的主键类型。主键类型就是数组元素的类型。比如说int[] 数组的主键类型就是int类型的对象。String[] 数组的主键类型就是String类型的类对象。例子如下： 代码将输出java.lang.String,并且这个主键类型是String数组的。 原文"},{"title":"Java反射9-泛型","date":"2017-02-26T06:53:28.000Z","url":"/2017/02/26/Java%E5%8F%8D%E5%B0%849-%E6%B3%9B%E5%9E%8B/","tags":["Java反射","Generic"],"categories":["Java译文"],"content":" The Generics Reflection Rule of Thumb Generic Method Return Types Generic Method Parameter Types Generic Field Types 我经常在一些文章或者论坛里面读到Java泛型在编译的时候已经被抹掉了，所以在运行时你不能获取到Java泛型。这完全是不对的。在少数情况下，可以在运行时访问泛型信息。这些情况实际上涵盖了我们对Java泛型信息的几个需求。本文将解释这些情况。 泛型的大体规则以下两种情形会使用到泛型： 将类/接口声明为可参数化。 使用可参数化的类。 当你创建一个类或者接口的时候，你看申明它可以参数化。java.util.List就是这种情况。比如用java.util.List你可以创建一个String的列表，而不是只能创建Object类型的列表。像java.util.List这种使用泛型的的情形在程序运行的时候是没有办法去获取泛型到底被参数成了什么类型。这是合理的，因为泛型能被参数化为当前程序的所有类型。但是在程序运行时候，当你检查使用了泛型的方法或者作用域时，你是能够获取到泛型到底被那种数据参数化了。简而言之：在运行时你是不能直接获取到泛型到底被那种数据参数化了，但是却可以通过使用泛型的方法和作用域来获取泛型的参数类型。或者说它有具体的参数化类型。接下来的几节将了解这些情况。 泛型方法的返回类型若果你获取到了java.lang.reflect.Method对象，是能够去获取到方法的返回类型的（注：泛型的类型的参数类型）。这种方式是不能获取到所有方法的泛型参数类型，但是却可以获取到类中定义的使用了泛型的成员变量类型。你可以阅读’Java反射-方法’来了解怎么获取Method对象。下面这个例子讲述了类中的一个方法的返回类型包含泛型： 在MyClass类中是能够获取到getStringList()方法返回的泛型数据类型的。或者说，是能够获取到getStringList()方法返回了一个String类型的List而不是只能知道返回了一个List。代码如下： 上面的代码片段将输出typeArgClass = java.lang.String。Type[]数组typeArguments将包含一个元素–一个代表实现了Type接口的java.lang.String类的对象。类实现类型接口。 泛型方法参数的类型你要可以放过Java反射获取带有泛型的参数的泛型类型。下面的例子中类中有个方法的参数是一个可参数化的List： 你可以获取到泛型参数的泛型类型： 代码将输出parameterArgType = java.lang.String。这Type[]数组parameterArgTypes将包含一个元素–一个代表实现了Type接口的java.lang.String类的对象。类实现类型接口。 泛型成员变量的泛型获取public的成员变量的泛型也是可以的。成员变量对象是类的成员-静态的或者实例变量。你可以阅读‘Java反射-成员变量’来了解怎样获取成员变量的对象。下面的例子是前面的例子，类中有一个叫做stringList的对象： 这段代码将输出fieldArgClass = java.lang.String。Type[]数组fieldArgTypes包含一个元素-一个代表实现了Type接口的java.lang.String类的对象。类实现类型接口。 原文"},{"title":"Java反射8-注解","date":"2017-02-26T06:27:05.000Z","url":"/2017/02/26/Java%E5%8F%8D%E5%B0%848-%E6%B3%A8%E8%A7%A3/","tags":["Java反射","Annotation"],"categories":["Java译文"],"content":" What are Java Annotations? Class Annotations Method Annotations Parameter Annotations Field Annotations 使用Java反射你可以在程序运行时获取到注解。 什么是Java注解注解是Java5开始新增的一个功能。注解是一种可以在Java代码插入的注释已经元素。在预编译工具编译的时候或者通过Java反射这些注解可以被获取到的。例子如下： TheClass类有一个注解@MyAnnoation是卸载顶部的。注解想接口一样来定义。比如： 在接口类名前面添加@符号就申明了一个注解。一旦你定义了注解，你就可以使用它比如在上文例子中那样。在注解的最顶部申明的@Retention(RetentionPolicy.RUNTIME)和@Target(ElementType.TYPE)说明了这个注解是怎么使用的。@Retention(RetentionPolicy.RUNTIME)说明了注解可以通过Java反射来获取。如果你不设置这句你就不能通过Java反射来获取这个注解。@Target(ElementType.TYPE)说明了注解只能在类或者接口的顶部使用。你也可以指定Method或者FIELD,或者你不申明这句让注解在所有的地方都可用。更多关于注解参考 类的注解在程序运行时你可以获取到类，方法或者成员变量域的注解。比如获取的所有类的注解对象： 你可以获取指定的注解对象： 方法的注解方法带有注解： 获取例子如下： 获取方法的指定的注解对象： 参数的注解给参数加注解也是可能的，比如： 获取方法参数的注解： 注意到Method.getParameterAnnotations()方法返回了方法每个参数的注解值是一个一个二维的数组。 成员变量的注解成员变量也是可以添加注解的比如： 获取成员变量的所有的注解对象： 获取指定的注解对象： 原文"},{"title":"Java反射7-私有成员变量域和方法","date":"2017-02-26T05:59:58.000Z","url":"/2017/02/26/Java%E5%8F%8D%E5%B0%847-%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%9F%9F%E5%92%8C%E6%96%B9%E6%B3%95/","tags":["Java反射","私有域和方法"],"categories":["Java译文"],"content":" Accessing Private Fields Accessing Private Methods 获取私有的成员变量域和方法也是可能的。这甚至不是那么的困难。在单元测试的时候是非常便利的。本文将讲述怎么去获取。注意：只有当你运行程序作为独立的Java应用的时候比如单元测试才能去获取私有的变量域和方法。如果你在程序运行的时候来做这件事，就需要SecurityManager来处理。 获取私有成员变量域为了去获取私有的成员变量域你需要使用Class.getDeclaredField(String name),和Class.getDeclaredFields()方法。记得前文说过的Class.getField(String name)和Class.getFields()这两个方法只会返回类中定义为public的成员变量域的对象。例子如下: 上述代码将会输出fieldValue = The Private Value，其值是orivateObject对象在创建的时候指定的私有值。注意到PrivateObject.class.getDeclaredField(&quot;privateString&quot;)方法，返回的值是当前类私有的成员变量域的对象，而不是是父类的值。注意到Field.setAcessible(true)这句代码，你设置了它可以通过反射来访问。所以你能访问到私有的（private）,受保护的（protected）属性，甚至是包范围类的即使它不是这个类的。当你使用常规的方法去访问它，编译器是不接受的。 获取私有的方法获取的方法你需要使用Class.getDeclaredMethod(String name, Class[] parameterTypes)和Class.getDeclaredMethods()方法。 Class.getMethod(String name, Class[] parameterTypes) 和 Class.getMethods()方法只会返回public的方法。例子如下： 上述代码将打印returnValue = The Private Value，其值是PrivateObject在创建的时候指定的值通过getPrivateString()获取到的。注意到PrivateObject.class.getDeclaredMethod(&quot;privateString&quot;),将返回当前类定义的私的方法而不是父类的私有方法。注意到Method.setAcessible(true)你是在了直达Method对象的访问属性。所以捏那个访问私有的，受保护的甚至是相同包的方法。常规的方法编译器是不接受的。原文"},{"title":"Java反射6-setter和getter","date":"2017-02-26T05:47:00.000Z","url":"/2017/02/26/Java%E5%8F%8D%E5%B0%846-setter%E5%92%8Cgetter/","tags":["Java反射","Setter和Getter"],"categories":["Java译文"],"content":"使用Java反射使得你能在程序运行时获取到类的方法。这就使得我们可以获取类中定义的getter和setter方法。你不能准确的获取getter和setter方法，但是遍历所有的方法来确定是不是getter和setter。首先告诉你getter和setter的规则： Getter，Getter方法是一get开头，没有参数和返回值。 Setter，Setter方法一set开头，有一个参数。 Setter方法可能有返回值要可能没有。有的返回为void，有些满足链试调用来设置值。因此你不能确定一个Setter方法的返回值。找到getter和setter方法的列子： 原文"},{"title":"Java反射5-方法","date":"2017-02-23T14:18:15.000Z","url":"/2017/02/23/Java%E5%8F%8D%E5%B0%845-%E6%96%B9%E6%B3%95/","tags":["Java反射","方法","Method"],"categories":["Java译文"],"content":" Obtaining Method Objects Method Parameters and Return Types Invoking Methods using Method Object 反射获取到类的方法是通过类java.lang.reflect.Method类来完成的。本文将介绍类Method. 获取方法对象方法对象可以向这样获取： methods返回的值是类中所有什么为public的方法。如果你知道某个方法的参数，你可以获取到特点的方法而不是获取所有的方法。比如例子中你知道方法的名称是doSomething,它的一个参数是String类型的，你可以这样获取： 如果没有这个方法，或者方法对应的参数不是String类型的将会抛出NoSucnMethodException。如果你试图获取一个无参的方法你一个传递null最为参数: 方法的参数和返回类型你可以这样获取方法的参数： 你可以这样获取方法的返回值： 操作方法你可以通过使用Method对象来调用对象方法： 这null参数表示的是你想调用方法的对象。如果一个方法是静态static的你应该传递一个null最为参数，而不是对应的类对象。但是你必须指定你操作的方法的每个参数的确定的值。本例中我使用了一个参数为String类型的方法，所以一个String值parameter-value1必须指定。 原文"},{"title":"Java反射4-成员变量","date":"2017-02-23T13:45:48.000Z","url":"/2017/02/23/Java%E5%8F%8D%E5%B0%844-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/","tags":["Java反射","成员变量","Field"],"categories":["Java译文"],"content":" Obtaining Field Objects Field Name Field Type Getting and Setting Field Values 通过Java反射你能获取到类的成员变量以及可以在运行时get/set他们的值。这是通过类java.lng.reflect.Fidld来完成的。记得去阅读Sun公司的JavaDoc。 获取成员变量成员变量是通过Class类获取的： fields数组的值与类中每个申明为public的成员变量对应。如果你知道类中成员变量的命名，你可以这样获取： 列子中返回类MyObject中申明为public的成员变量的对象: 如果getField()方法没有获取到指定的参数对应的成员变量对象，将会抛出NoSuchFieldException。 成员变量名称一旦你成功获取了成员变量的对象，你可以获取到它在类中定义的名称。 成员变量类型通过Field.getType()方法你可以确定成员变量的类型： 获取或者改值一旦你获取到了成员变量的对象你可以通过Field.get()和Field.set()方法来改变它的值: 传递给get和set方法的objectInstance参数应该是拥有该字段的类的实例。例子中使用到了类MyObject对象，因为someField这个成员变量对象对应的成员变量本身就是是MyObject类的成员。get和set方法传递null来操作static的成员变量域，而不是类的对象。 原文"},{"title":"Java反射3-构造器","date":"2017-02-23T13:26:40.000Z","url":"/2017/02/23/Java%E5%8F%8D%E5%B0%843-%E6%9E%84%E9%80%A0%E5%99%A8/","tags":["Java反射","构造器","Constructors"],"categories":["Java译文"],"content":" Obtaining Constructor Objects Constructor Parameters Instantiating Objects using Constructor Object 在程序运行时，能通过Java反射你能获取到类的构造器。这是通过Java类java.lang.reflect.Constructor完成的。通过这篇文你将得到更多关于构造器的信息。 获取构造器对象构造器对象是通过Class对象获取的，比如： 这个constructos数组中的值是类中每个申明为public的构造器。如果你知道类中构造器的一些更具体的参数，你可以直接获取他而不是直接获取所有的。例子中返回了中有String参数的构造器的对象。 如果类中没有申明有String参数的构造器，即没有找到时，getConstructor()方法会抛出NoSuchMethodException异常。 构造器的参数你可以获取一个构造器的参数： 生成类对象你可以通过构造器生产对应的类对象： Constructor.newInstance()方法指定了一系列的参数，你必须准确的指定每个参数使得于你使用的构造器参数对应。在这个列子中，我们使用了一个带有String参数的构造器，所以必须知道一个String的值。 原文"},{"title":"Java反射2-类","date":"2017-02-22T14:00:21.000Z","url":"/2017/02/22/Java%E5%8F%8D%E5%B0%842-%E7%B1%BB/","tags":["Java反射","Class"],"categories":["Java译文"],"content":" The Class Object Class Name Modifiers Package Info Superclass Implemented Interfaces Constructors Methods Fields Annotations Java反射使得你能在运行时检查类信息。一般来说反射常用的方式是检查类的信息。你能获取到的类信息有： Class Name（类名） Class Modifies（修饰符）,public,private,synchronized等。 Package Info（包信息） Superclass（父类） Implemented Interfaces（实现的接口） Constructors（构造器） Methods（方法） Fields（成员变量） Annotation（注解） 加上等多的Java类相关信息。更多的信息请看JavaDoc for java.lang.Class。本文会简明的阐释上面提到的信息，更加详细的阐述上面的一些主。例如在本文将教你如何获取所有类的方法或者指定的方法，但是在其他章节将教你如何使用获取到的方法，怎样去发现你指定参数与之匹配的方法，以及如果存在多个具有相同方法名称的方法，怎样去找到你指定参数的方法，执行反射出来的放回会抛出什么异常，如何发现getter和setter方法。本文旨在介绍CLass类以及你通过Class类你能获取到上面信息。 Class类在你获取类信息之前你先要获取到Class类对象。在Java语言里面所有的类包括基本的变量（int，long，float等）以及数组都包含Class类对象（ have an associated Class object）。在编译期间，如果你知道一个类的名称你就能获取一个Class对象，像这样：Class myObjectClass = MyObject.class如果在编译期间你不知道类名，你知道类的全路径名称你可以像这样获取Class对象： 当我们使用Class.forName()方法的时候你必须知道类的权路径名称。就是类的包名信息。比如，MyObject类是在包com.jenkov.myapp中那么全路径就是com.jenkov.myapp.MyObject。如果一个类没有被找到，程序运行时Class.forName()方法会抛出ClassNotFoundException异常。 类名从一个类（Class）对象你又两种方式获取类名。全路径名称（包含包名信息）是通过getName()方法： 如果不想获取全路径名称只想获取类名可以通过getSimpleName()方法获取： 修饰符通过Class对象你能获取到类的修饰符。类的修饰符包括“public”，“private”，“static”等待。 修饰符已整形的方式返回，其值是被Java预想定义好的。你可以通过java.lang.reflect.Modifier的方法来判断到达时那种修饰符： 包信息你可以通过一下方式Class对象获取包信息： 通过Package对象你能获取到他的路径。也能获取到在Manifest中指定JAR包指定的信息。你可以通过java.lang.Package了解具体的信息。 父类比如： 获取到的父类的Class对象就其他的Class一样，你可以继续获反射出类的其他信息。 实现的接口我们可以回去到类实现的接口： 类能实现很多的接口方法。因此以数组的形式返回类实现的接口方法。接口也是可以通过Java反射找到的。注意：反射只能找到被当前类实现了的接口。如果父类实现的接口方法，子类如果没有重载改方法，是不会再数组中返回。即使这个类拥有这个方法，因为他的父类实现了它。所以为了得到一个类的所有接口方法，你必须的递归类和他的父类以及父类的父类。 构造器获取构造器的方式大概是这样： Constructor[] constructors = aClass.getConstructors();更多关于构造器的描述请见：Constructors。 成员变量获取变量域的方式大概是这:Field[] method = aClass.getFields();更多信息:Fields。 注解Annotation[] annotations = aClass.getAnnotations();更多信息：Annotations 原文"},{"title":"Java反射1-教程","date":"2017-02-21T14:32:55.000Z","url":"/2017/02/21/Java%E5%8F%8D%E5%B0%841-%E6%95%99%E7%A8%8B/","tags":["Java反射","反射"],"categories":["Java译文"],"content":"Java反射指在程序运行的时候，能检查类，接口，域，方法等信息。在编译的时候也能通过反射创建对象，调用对象的方法以及get/set字段。Java反射是十分强大且有用的。例如像 Butterfly Persistence当在运行时将对象映射到数据库中的表。或者像，当在运行时将脚本语言中的语句映射到实际对象上的方法调用时，网上已经有众多的反射教程了。但是包括Sun公司在内的大多数反射教程，仅仅只是接触到反射的表层。这篇教程将会更加的深入讲解反射比起那些我见过的。它将讲解反射的基本原理比如怎样操作数组的，泛型和动态代理，动态的加载类和重新加载。也将告诉你怎样去做一下更特别的任务，像获取一个类的所有方法，甚至是私有的变量。这篇教程理清运行时的可用泛型。有些人生成泛型在运行时已经消失了。这是不对的。本教程基于Java 1.6。 一个例子一个使用反射的列子： 这个例子获取到的MyObject类的对象。打印了MyObject的所有的方法。本教程的其余部分（在其他文本中）将进一步详细解释所有这些工作原理。原文"},{"title":"ShortCuts","date":"2017-02-15T14:11:23.000Z","url":"/2017/02/15/Shortcuts/","tags":["ShortCuts","快捷键"],"categories":["Android"],"content":"ShortCut是Android7.1推出的一个新功能，一般点击app的图标会打开一个app，这个新功能是你长按app图标的时候，弹出一个快捷的操作的选择框，以快速使用app的功能(不是其他的app)。 1.Static Shortcut像在xml里面注册广播一样，在manfiest中注册Shortcuts。 1.1在xml目录下新建一个Shortcuts文件 shortcutId:唯一的idshortcutLongLabel:长描述，优先显示shortcutShortLabel:短描述shortcutDisabledMessage:shortcut不可用时展示的文字icon:图标enabled:设置是否可用 1.2找启动页面找到在被android.intent.action.MAIN和android.intent.category.LAUNCHER所标记Activity,也就是启动页面。 1.3添加Shortcut 2.Dynamic Shortcut在代码中动态注册Shortcuts。主要是通过ShortManager来实现。 新增。setDynamicShortcuts和addDynamicShortcuts() 更新。updateShortcuts() 删除。 removeDynamicShortcuts()和removeAllDynamicShortcuts()。 通常在添加之前要判断一下当前应用支持几个Shortcut。getMaxShortcutCountPerActivity()然后在添加。注意targetSdkVersion 不能小于25。 3.Pinned Shortcut在API 26 之前加上权限com.android.launcher.permission.INSTALL_SHORTCUT后可以这样创建 INSTALL_SHORTCUT和UNINSTALL_SHORTCUT从26起就不支持了 In Android O (API level 26) and higher, the INSTALL_SHORTCUT broadcast no longer has any effect on your app because it’s a private, implicit broadcast.Instead, you should create an app shortcut by using the requestPinShortcut() method from the ShortcutManager class 需要使用ShortcutManager来创建快捷键，官方最佳实践App Shortcuts。创建桌面的Widget也是要用新的方式来创建Build an App Widget 注意： 官方例子android-AppShortcuts动态添加网址快捷键,动态创建快捷键addDynamicShortcuts(List)的不一定会成功，在我的华为AUM-AL20上手机上不行,后来发现别个是创建Dynamic快捷键的。 requestPinShortcut()系统的授权界面会有延时，Oppo R15。 ShortcutManager.createShortcutResultIntent()也是可以用来创建PendingIntent的intent参数，这个方法文档上说用来自定义UI的。 Thanks shortcuts shortcuts翻译 guide-shortcuts blog-whats-new-for-shortcuts-and-widgets-in What’s new for shortcuts and widgets in Android O code"},{"title":"发布开源项目到JCenter","date":"2017-01-14T05:54:47.000Z","url":"/2017/01/14/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%B0jCenter/","tags":["开源","JCenter仓库","AndroidStudio"],"categories":["Android"],"content":"思路是： 独立开源模块 上传到Bintray 发布到JCenter独立模块就是抽出相应的代码到独立的modle里面，以便生成aar文件。比如我将的我banner部分代码封装在一个modle里面。发布到Bintray至于为什么要发布到bintray上 参考注册Bintray账号有的话请跳过，没有的话 传送门 。如果是企业级别的就注册企业的，个人开发者就注册个人的，企业的要收费，有30天试用期。注册之后可以新建一个maven库。配置Bintray添加插件因为要使用到Bintray和Maven的服务，在项目的的build.gradle文件中添加两个插件，参考 Bintray plugin maven plugin 大概长这个样子 配置开发者信息在local.properties中添加: user:如果user你不记得是什么了可以打开的bintray主页面即：这个xxx就是你需要填写的user。API key:在个人页面点击头像，选择view prefile。在做上方，点击头像羡慕的Edit，然后你就看见了涉及到隐身开发者信息，所以最好不要同步到开源社区上了，当然在这个信息化时代，不存在什么个人隐私信息。 配置项目信息在modle下面新建一个project.properties 文件，用于几种记录信息并输入： 然后在modler下新建bintrayUpload.gradle文件，填入： 这个基本上没什么修改的。最后在modle的build.gradle的文末(ps:不要添加在文首)添加：apply from: &quot;bintrayUpload.gradle&quot;到处配置以及结束。 上传的bintray在项目的gradle里面，点击gradle选择modle项目，以次输入并点击确认 : install bintrayUpload也可以在gradle的命令行里面输入: gradlew install gradlew bintrayUpload在linux或者mac下如果你没有将gradle命令添加到全局那么在gradlew前面需要添加./上传成功后你的项目就在bintray的maven里面的。你可以在查看是否上传没有。发布到jCenter这个时候的开源库还是在你的私人仓库里面引用方式是：在modle里面添加你的maven url，然后在complie你的项目名字。maven库的引用发布到jCenter方式很简单，只需点击Add to JCenter审核成功后你就可以快乐的引用了。遇到的问题 如果你是个人用户的话，注册bintray账号就别注册企业版的，如果你需要消费，哪也无妨。个人版的注册在页面的最底部。当时也是先注册，在注销(会删除所有的库)，在注册。 error： Error:(3, 0) No service of type Factory&lt;LoggingManagerInternal&gt; available in ProjectScopeServices. &lt;a href=&quot;openFile:/Users/better/Documents/WorkSpace/git/DAndroid/demo_android/BBanner/banner/build.gradle&quot;&gt;Open File&lt;/a&gt; 使用bintray和maven插件的时候最好使用最新的 Error : cause android.compileSdkVersion is missing 申明bintrayUpload.gradle时最好不要紧跟着申明modle语句之后,如果你没分了配置文件的话不会遇见这个错误。 Thinks5分钟发布Android Library项目到JCenter发布aar到jcenter的正确姿势使用Android Studio把自己的Android library分发到JCenter"},{"title":"Maven库","date":"2017-01-13T09:18:01.000Z","url":"/2017/01/13/Maven%E5%BA%93/","tags":["Maven","Android库","JCenter"],"categories":["Android"],"content":"MavenMaven 是一个管理项目的工具 Apache Maven。Maven包 是由所谓 POM（Project Object Model）所定义的文件包。andorid开发中一般会用到两种远程Maven仓库即：jCenter和mavenCentral。android studio中默认是支持jCenter库的。至于原因嘛肯定是jCenter比mavenCentral更好用撒，里面的东西更多点。 maven包构成group_id:artifact_id:version 参考squareup的产品： jCenter是由bintray在维护的maven库。引入方式： 这个是在项目的根目录下build.gradle下面默认引入,不需要修改。 mavenCentral引入方式： 很明显我们不会这样将jcenter替换为mavenCentral。一般我们在需要使用的modle下面的build.gradle下引入。 添加地址 分别是引入远程服务器，本地，内网的仓库。 导包 thinks拥抱 Android Studio 之四：Maven 仓库使用与私有仓库搭建"},{"title":"AndroidStudioSHA1值","date":"2017-01-03T14:30:01.000Z","url":"/2017/01/03/Android%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E7%9A%84sha1%E5%80%BC/","tags":["SHA1","Andorid 签名证书SHA1"],"categories":["Android"],"content":"sha1在androidstudio下可以这样获取： 打开项目的gradle信息 点击Task任务下的android目录下的signReport 控制台查看sha1 "},{"title":"N文件共享之android.os.FileUriExposedException","date":"2016-12-30T01:23:18.000Z","url":"/2016/12/30/Android%20N%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B9%8Bandroid-os-FileUriExposedException/","tags":["Android N","FileUriExposedException","文件共享"],"categories":["Android-Error"],"content":"在Android N上直接分享文件会报错，比如调起安装 APK 文件： 由于Android N出于安全考虑，禁止用户直接共享文件，必须以provider的方式来共享文件。即： 禁止以公开你的文件的方式共享文件。 以content://URI并授予URI临时访问权限的方式来访问 解决方法是使用FileProvider来规避,安装一下三个步凑来添加 添加Provider注意：authorities：app的包名grantUriPermissions：必须是true，表示授予 URI 临时访问权限exported：false，不导出给其他APP用resource：中的@xml/file_paths是我们接下来要添加的文件 添加分享文件路径信息 path可以选择的路径有： tag 对应的目录路径 &lt;files-path name=”name” path=”path”/&gt; Context.getFilesDir() &lt;external-path name=”name” path=”path”/&gt; Environment.getExternalStorageDirectory() &lt;cache-path name=”name” path=”path”/&gt; Context.getCacheDir() &lt;external-files-path name=”name” path=”path”/&gt; Context#getExternalFilesDir(String) &lt;external-cache-path/ name=”name” path=”path”&gt; Context.getExternalCacheDir() &lt;external-media-path name=”name” path=”path” /&gt; Context.getExternalMediaDirs() name：就是你给这个访问路径起个名字,只是显示用随便取 path：需要临时授权访问的路径名称（.代表当前路径下所有路径） 比如-来源： 适配android N涉及到文件分享的时候，做下适配，使用Fileprovider来生成Uri 打开apk：application/vnd.android.package-archive打开图片：image/* 最后需要将对应的Url添加访问权限添加flag,该方式主要用于针对intent.setData，setDataAndType以及setClipData相关方式传递uri的 或者找出匹配的Intent使用函数来 授权 grantUriPermission(String toPackage, Uri uri, int modeFlags) 移除权限 revokeUriPermission(Uri uri, int modeFlags); 参考developer-FileProvider"},{"title":"查看Android手机CPU架构","date":"2016-12-22T14:13:45.000Z","url":"/2016/12/22/%E6%9F%A5%E7%9C%8Bandroid%E6%89%8B%E6%9C%BAcpu%E6%9E%B6%E6%9E%84/","tags":["CPU架构","CPU"],"categories":["Android"],"content":"进入bash窗口，执行：adb shellcd /proccat cpuinfo "},{"title":"Github Pages和Hexo博客搭建指南","date":"2016-11-20T12:30:55.000Z","url":"/2016/11/20/Github%20pages%E5%92%8Chexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/","tags":["Github Pages","博客","Hexo","域名","备份"],"categories":["Blog"],"content":"博客终于搭建好了，前前后后差不多花了两天时间。这里对自己搭建过程中做一下记录。 搭建github Pages 首先你得有个github账号，如果没有注册。 创建知识库 repo这里要注意，由于每个repo都可以创建对应的Pages文档，但是官方规定[userName].github.io这样的网址只能有一个。所以对于你所创建的repo名称有以下两种： 非userName.github.io。这时你所创建的网址是userName.github.io/repo/，对于这种方式你可以灵活配置Pages来源于master或gh-pages分支。 userName.github.io。网址是userName.github.io。Pages数据只能是在master上。这里搭建个人博客，所以取名是userName.github.io,请注意是repo的命名。 设置点击知识库的设置配置Pages的数据来源即选着分支。选择一些官方的主题。预览到此你的个人博客就搭建完了地址:userName.github.io。添加ssh配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。 查看是否有ssh。cd ~/.ssh 有就备份删除。cp -R ~/.ssh ~/.ssh_bakrm -R ~/.ssh 创建。ssh-keygen -t rsa -C &quot;你在Github上的邮箱&quot;第一次要输入file名字，直接回车即可，默认文件名为id_前缀，然后会被要求输入个密码并且确认。在GitHub账户中添加你的公钥more id_rsa.pub查看公钥里的内容并且全部复制下来(包括开头ssh-rsa和结尾邮箱)。如果闲麻烦可以。clip id_rsa.pub进入github的账号设置界面，并选择左侧边栏的ssh选项。然后新增ssh将刚刚copy的秘钥填入进去。测试连接ssh userName@github.com成功返回：Hi molon! You&#39;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 使用Hexo搭建环境安装node.js和git。命令行执行： 创建hexo文件夹在本地磁盘任意位置以此执行命令： 配置这里主要注意url和root这两个节点的配置。部署节点的配置 branch在master就填master，在gh-pages就写gh-pages。部署命令hexo clean清空缓存hexo generate简写 hexo g 即：生成网页文件。hexo server简写 hexo s 即：在本地查看效果hexo deploy发布到githubhexo g -d 生成并发布如果是用gh-pages的方式deploy的要注意，部署过后，如果设置的theme没有效果则需要将_config.yml的root要改為你repository的名字root: /your_repository/ 参考绑定域名推存在阿里云上买个域名。指定域名然后hexo的\\hexo\\source新增CNAME文件(没有后缀名)，打开将你买的域名填入，注意不能有前缀http：//然后部署，提交。成功后你可以在repo的master根目录下看到新增CHAME文件以及指向的地址。修改DNS在阿里云的个人中心点击域名 点击管理 将dns值修改为:f1g1ns2.dnspod.net f1g1ns1.dnspod.net 添加域名解析 还是在刚刚修改DNS的页面，选择域名解析，把你的Pagers地址加上。 然后在DNSPOD把你刚刚买的域名添加进来。然后将你的userName.github.io的IP添加进来(在cmd或者bash窗口ping userName.github.io得到IP)，图中红线处。 备份备份以备不时之需。使用hexo，如果换了电脑怎么更新博客？hexo-git-backup 参考github Pages官网文档Hexo官方文档Github Pages和Hexo简明教程如何在Mac下配置Github和Bitbucket的SSH"},{"title":"projects","date":"2019-09-22T09:35:52.000Z","url":"/projects/index.html","content":""},{"title":"about","date":"2019-09-22T09:36:02.000Z","url":"/about/index.html","content":"Android 开发工程师"},{"title":"categories","date":"2019-09-22T09:35:56.000Z","url":"/categories/index.html","content":""},{"title":"tags","date":"2019-09-22T09:35:59.000Z","url":"/tags/index.html","content":""},{"title":"search","date":"2019-09-22T10:13:33.000Z","url":"/search/index.html","content":""}]